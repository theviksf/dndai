# D&D Adventure Game - OpenRouter Powered

## Overview

This project is an interactive Dungeons & Dragons text adventure game that uses OpenRouter's AI models to create dynamic storytelling and manage the game state. Players can create custom characters, go on quests, and experience AI-driven narratives that track game state in real-time. The application uses a dual-LLM architecture, allowing users to choose their preferred models for both narrative generation and game state parsing. The goal is to provide an immersive, AI-driven narrative experience that adapts to player choices, offering high replayability and a personalized D&D adventure.

The application is deployed with a hybrid architecture supporting both local development (Replit) and production deployment (Vercel).

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

The frontend is built with React, TypeScript, Vite, Wouter for routing, and Shadcn UI (Radix UI + Tailwind CSS) for a D&D-themed design. State management uses React hooks for local state and TanStack Query for server state.

The main game interface features a three-panel layout:
- **Chat Area (Narrative Panel)**: Displays AI-generated story and action input.
- **Icon Rail**: A fixed sidebar with icons for various game sections (inventory, spells, locations, etc.) and notification badges.
- **Info Drawer**: A sliding panel (desktop) or Sheet component (mobile) showing content for the selected section.

Key components include the Home page, Settings page, Character Creation page, CharacterStatsBar, NarrativePanel, IconRail, InfoDrawer, eight modular Info Panels, EntityDetailSheet for detailed views, and Header Navigation. Interactions are designed for intuitive navigation and responsiveness across devices.

### Backend Architecture

The backend utilizes a dual-environment setup: an Express server with Vite middleware for Replit development, mirroring serverless functions for Vercel production. All API routes are RESTful and proxy OpenRouter API for model fetching and streaming chat completions via SSE. API key management includes a fallback chain. Prompt management uses default markdown files and client-side IndexedDB for custom prompts.

### Multi-Agent LLM Architecture

The system employs specialized LLMs for different tasks:
- **Primary LLM (Narrative Agent)**: Generates rich, contextual narrative responses.
- **Parser LLM (State Extraction Agent)**: Extracts structured game state updates and generates history recaps.
- **Revelations Agent**: Identifies and tracks backstory revelations.
- **Image Agent**: Generates AI images for characters, NPCs, and locations using Google's Gemini 2.5 Flash Image Preview.
- **Backstory Agent**: Generates structured backstories for various entities, ensuring narrative consistency.
- **Checker Agent**: Ensures entity consistency by validating fields against backstories.
- **Lore Agent**: Generates rich world lore and backstory.

The execution flow involves a sequence of agent interactions from player action to world enrichment, with streaming for the Primary LLM and robust error handling for LLM responses. Context management is optimized for coherence and cost efficiency, and all agent prompts are customizable.

### NPC-to-Companion Migration System

When an NPC becomes a companion, their data is automatically migrated to prevent duplication and preserve continuity. This includes `imageUrl`, `backstory`, `revelations`, and `memories`. NPC fields are intelligently mapped to companion equivalents, and the NPC is removed from the `encounteredCharacters` list.

### Character Memories System

NPCs and companions accumulate personal memories of interactions with the player character. Memories are generated by the Parser LLM after each turn, from the character's perspective, and are used by the Primary LLM to inform dialogue and behavior, creating authentic relationship development.

### Data Storage Solutions

**IndexedDB Storage (Primary)**: All game data is stored in browser IndexedDB (Dexie.js), supporting multi-session management and migration. LZ-String compression runs in a Web Worker, and saves are debounced and flushed on unload to prevent data loss. A storage analysis tool provides detailed insights into IndexedDB usage.

**Snapshot System (Undo/Rollback)**: Turn snapshots are stored in IndexedDB for game state restoration. Players can select any snapshot to revert the game to that point, with snapshots optimized for storage by limiting debug logs and pruning older entries.

**Image Storage (Cloudflare R2)**: AI-generated images are stored in Cloudflare R2 using AWS S3-compatible API to avoid local storage quotas, with structured filenames for identification.

## External Dependencies

### Third-Party Services

- **OpenRouter**: Unified API gateway for various LLM providers (Anthropic Claude, OpenAI GPT, Google Gemini).
- **Cloudflare R2**: Object storage service for AI-generated images.
- **Neon Database**: Serverless PostgreSQL for database connections (future integration).

### UI Component Libraries

- **Radix UI**: Accessible, unstyled React components.
- **Shadcn UI**: Pre-styled components built on Radix UI.
- **Embla Carousel**: Carousel functionality.

### Utility Libraries

- **TanStack Query**: Server state management.
- **React Hook Form + Zod**: Form management and validation.
- **date-fns**: Date manipulation.
- **Drizzle ORM + Drizzle Zod**: Type-safe database queries (future integration).
- **Tailwind CSS**: Utility-first CSS framework.
- **Wouter**: Lightweight client-side routing.
- **React Markdown + Remark GFM**: Markdown rendering.