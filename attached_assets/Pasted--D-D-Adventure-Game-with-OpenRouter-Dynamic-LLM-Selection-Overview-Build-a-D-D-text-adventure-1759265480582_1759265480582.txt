# D&D Adventure Game with OpenRouter & Dynamic LLM Selection

## Overview
Build a D&D text adventure game using OpenRouter with user-selectable LLMs:
- **Primary LLM** (User selected): Generates rich, immersive game responses
- **Parser LLM** (User selected): Extracts and updates game state + creates compressed recaps
- **OpenRouter Integration**: Fetch available models and let user choose

## OpenRouter Integration

### 1. **Fetch Available Models**

```javascript
// Fetch all available models from OpenRouter
async function fetchOpenRouterModels() {
  const response = await fetch('https://openrouter.ai/api/v1/models', {
    headers: {
      'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
    }
  });
  
  const data = await response.json();
  return data.data; // Array of model objects
}

// Model object structure from OpenRouter:
{
  id: "anthropic/claude-3-opus",
  name: "Claude 3 Opus",
  pricing: {
    prompt: "0.000015",    // per token
    completion: "0.000075"
  },
  context_length: 200000,
  // ... other fields
}
```

### 2. **Model Selection UI**

```html
<!-- Settings/Configuration Panel -->
<div class="llm-settings">
  <h3>LLM Configuration</h3>
  
  <div class="model-selector">
    <label>Primary LLM (Narrative Generation):</label>
    <select id="primary-llm">
      <!-- Populated dynamically -->
    </select>
    <span class="cost-estimate" id="primary-cost"></span>
  </div>
  
  <div class="model-selector">
    <label>Parser LLM (State Extraction):</label>
    <select id="parser-llm">
      <!-- Populated dynamically -->
    </select>
    <span class="cost-estimate" id="parser-cost"></span>
  </div>
  
  <button onclick="saveModelSelection()">Save Configuration</button>
  
  <div class="recommended-configs">
    <h4>Recommended Configurations:</h4>
    <button onclick="setConfig('balanced')">Balanced (Claude Opus + Haiku)</button>
    <button onclick="setConfig('premium')">Premium (GPT-4 + Claude Haiku)</button>
    <button onclick="setConfig('budget')">Budget (GPT-3.5 + Gemini Flash)</button>
  </div>
</div>
```

### 3. **Populate Model Dropdowns**

```javascript
async function populateModelSelectors() {
  const models = await fetchOpenRouterModels();
  
  // Sort by pricing and capability
  const sortedModels = models.sort((a, b) => {
    const aCost = parseFloat(a.pricing.prompt) + parseFloat(a.pricing.completion);
    const bCost = parseFloat(b.pricing.prompt) + parseFloat(b.pricing.completion);
    return bCost - aCost; // Expensive first (usually better)
  });
  
  const primarySelect = document.getElementById('primary-llm');
  const parserSelect = document.getElementById('parser-llm');
  
  sortedModels.forEach(model => {
    // Primary LLM dropdown
    const primaryOption = document.createElement('option');
    primaryOption.value = model.id;
    primaryOption.textContent = `${model.name} ($${formatCost(model.pricing)}/turn)`;
    primaryOption.dataset.pricing = JSON.stringify(model.pricing);
    primarySelect.appendChild(primaryOption);
    
    // Parser LLM dropdown (clone)
    const parserOption = primaryOption.cloneNode(true);
    parserSelect.appendChild(parserOption);
  });
  
  // Set defaults
  setDefaultModels(sortedModels);
}

function formatCost(pricing) {
  // Estimate cost per turn (1500 prompt + 600 completion tokens)
  const promptCost = parseFloat(pricing.prompt) * 1500;
  const completionCost = parseFloat(pricing.completion) * 600;
  return ((promptCost + completionCost) * 1000).toFixed(4); // in dollars
}

function setDefaultModels(models) {
  // Find good defaults
  const primaryDefault = models.find(m => 
    m.id.includes('claude-3-opus') || m.id.includes('gpt-4')
  );
  const parserDefault = models.find(m => 
    m.id.includes('haiku') || m.id.includes('gpt-3.5') || m.id.includes('gemini-flash')
  );
  
  if (primaryDefault) {
    document.getElementById('primary-llm').value = primaryDefault.id;
  }
  if (parserDefault) {
    document.getElementById('parser-llm').value = parserDefault.id;
  }
}
```

### 4. **Recommended Configurations**

```javascript
const RECOMMENDED_CONFIGS = {
  premium: {
    primary: 'anthropic/claude-3-opus',
    parser: 'anthropic/claude-3-haiku',
    description: 'Best quality, ~$0.03-0.05/turn'
  },
  balanced: {
    primary: 'anthropic/claude-3-sonnet',
    parser: 'anthropic/claude-3-haiku',
    description: 'Great quality, ~$0.01-0.02/turn'
  },
  budget: {
    primary: 'openai/gpt-3.5-turbo',
    parser: 'google/gemini-flash-1.5',
    description: 'Good quality, ~$0.001-0.003/turn'
  },
  experimental: {
    primary: 'meta-llama/llama-3.1-70b-instruct',
    parser: 'meta-llama/llama-3.1-8b-instruct',
    description: 'Open source, ~$0.001-0.002/turn'
  }
};

function setConfig(configName) {
  const config = RECOMMENDED_CONFIGS[configName];
  document.getElementById('primary-llm').value = config.primary;
  document.getElementById('parser-llm').value = config.parser;
  updateCostEstimate();
}
```

### 5. **OpenRouter API Call Function**

```javascript
async function callOpenRouter(modelId, messages, systemPrompt, maxTokens = 1000) {
  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
      'HTTP-Referer': window.location.href, // Required by OpenRouter
      'X-Title': 'D&D Adventure Game', // Optional, for rankings
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: modelId,
      messages: [
        { role: 'system', content: systemPrompt },
        ...messages
      ],
      max_tokens: maxTokens,
      temperature: 0.7,
      // Optional: add routing preferences
      route: 'fallback', // Will try backup models if primary fails
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`OpenRouter API error: ${error.error?.message || 'Unknown error'}`);
  }
  
  const data = await response.json();
  return {
    content: data.choices[0].message.content,
    usage: data.usage,
    model: data.model // Actual model used (might differ if fallback)
  };
}
```

### 6. **Game Flow with Selected Models**

```javascript
// Store selected models in game config
const gameConfig = {
  primaryLLM: 'anthropic/claude-3-opus',
  parserLLM: 'anthropic/claude-3-haiku',
  // ... other config
};

async function processPlayerAction(action) {
  try {
    // 1. Prepare context for Primary LLM
    const context = prepareContext(gameState, recentHistory, action);
    
    // 2. Call Primary LLM (selected model)
    console.log(`Calling Primary LLM: ${gameConfig.primaryLLM}`);
    const narrativeResponse = await callOpenRouter(
      gameConfig.primaryLLM,
      [{ role: 'user', content: JSON.stringify(context) }],
      DM_SYSTEM_PROMPT,
      800 // max tokens for narrative
    );
    
    console.log(`Primary LLM used: ${narrativeResponse.model}`);
    console.log(`Tokens used: ${narrativeResponse.usage.total_tokens}`);
    
    // 3. Call Parser LLM (selected model)
    console.log(`Calling Parser LLM: ${gameConfig.parserLLM}`);
    const parserResponse = await callOpenRouter(
      gameConfig.parserLLM,
      [{
        role: 'user',
        content: JSON.stringify({
          narrative: narrativeResponse.content,
          currentState: gameState
        })
      }],
      PARSER_SYSTEM_PROMPT,
      500 // max tokens for parsing
    );
    
    const parsedData = JSON.parse(parserResponse.content);
    
    // 4. Update game state
    applyStateUpdates(gameState, parsedData.stateUpdates);
    gameState.recap.push(parsedData.recap);
    updateRecentHistory(action, narrativeResponse.content);
    
    // 5. Display to player
    displayNarrative(narrativeResponse.content);
    displayChoices(parsedData.choices);
    updateUI(gameState);
    
    // 6. Log costs
    logTurnCost(narrativeResponse, parserResponse);
    
  } catch (error) {
    console.error('Error processing action:', error);
    displayError(error.message);
  }
}
```

### 7. **Cost Tracking**

```javascript
// Track cumulative costs
const costTracker = {
  totalTurns: 0,
  primaryTokens: { prompt: 0, completion: 0 },
  parserTokens: { prompt: 0, completion: 0 },
  estimatedCost: 0
};

function logTurnCost(primaryResponse, parserResponse) {
  costTracker.totalTurns++;
  
  // Get pricing for models
  const primaryPricing = getModelPricing(gameConfig.primaryLLM);
  const parserPricing = getModelPricing(gameConfig.parserLLM);
  
  // Calculate costs
  const primaryCost = 
    (primaryResponse.usage.prompt_tokens * parseFloat(primaryPricing.prompt)) +
    (primaryResponse.usage.completion_tokens * parseFloat(primaryPricing.completion));
  
  const parserCost = 
    (parserResponse.usage.prompt_tokens * parseFloat(parserPricing.prompt)) +
    (parserResponse.usage.completion_tokens * parseFloat(parserPricing.completion));
  
  const turnCost = primaryCost + parserCost;
  costTracker.estimatedCost += turnCost;
  
  console.log(`Turn ${costTracker.totalTurns} cost: $${turnCost.toFixed(6)}`);
  console.log(`Total session cost: $${costTracker.estimatedCost.toFixed(4)}`);
  
  // Update UI
  updateCostDisplay();
}

function updateCostDisplay() {
  document.getElementById('session-cost').textContent = 
    `Session Cost: $${costTracker.estimatedCost.toFixed(4)} (${costTracker.totalTurns} turns)`;
}
```

### 8. **Model Information Cache**

```javascript
// Cache model information to avoid repeated API calls
let modelCache = null;

async function getModelPricing(modelId) {
  if (!modelCache) {
    modelCache = await fetchOpenRouterModels();
  }
  
  const model = modelCache.find(m => m.id === modelId);
  return model ? model.pricing : { prompt: '0', completion: '0' };
}

async function getModelInfo(modelId) {
  if (!modelCache) {
    modelCache = await fetchOpenRouterModels();
  }
  
  return modelCache.find(m => m.id === modelId);
}
```

## Complete UI Structure

```html
<!DOCTYPE html>
<html>
<head>
  <title>D&D Adventure</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Settings Modal -->
  <div id="settings-modal" class="modal">
    <div class="modal-content">
      <h2>Game Settings</h2>
      
      <div class="llm-config">
        <h3>LLM Configuration</h3>
        
        <div class="model-selector">
          <label>Primary LLM (Story Generation):</label>
          <select id="primary-llm" onchange="updateCostEstimate()">
            <!-- Populated dynamically -->
          </select>
          <div class="model-info">
            <span id="primary-context"></span>
            <span id="primary-cost"></span>
          </div>
        </div>
        
        <div class="model-selector">
          <label>Parser LLM (State Management):</label>
          <select id="parser-llm" onchange="updateCostEstimate()">
            <!-- Populated dynamically -->
          </select>
          <div class="model-info">
            <span id="parser-context"></span>
            <span id="parser-cost"></span>
          </div>
        </div>
        
        <div class="cost-estimate">
          <strong>Estimated Cost per Turn: <span id="turn-cost-estimate">$0.00</span></strong>
        </div>
        
        <div class="preset-configs">
          <h4>Quick Presets:</h4>
          <button onclick="setConfig('premium')">üåü Premium</button>
          <button onclick="setConfig('balanced')">‚öñÔ∏è Balanced</button>
          <button onclick="setConfig('budget')">üí∞ Budget</button>
          <button onclick="setConfig('experimental')">üß™ Experimental</button>
        </div>
      </div>
      
      <button onclick="saveSettings()">Save & Start Game</button>
    </div>
  </div>

  <!-- Main Game UI -->
  <div class="game-container">
    <!-- Left Sidebar: Player Stats -->
    <aside class="left-sidebar">
      <h2 id="player-name">Character</h2>
      <div class="stats">
        <div><strong>Race:</strong> <span id="player-race"></span></div>
        <div><strong>Class:</strong> <span id="player-class"></span></div>
        <div><strong>Level:</strong> <span id="player-level"></span></div>
        <div><strong>XP:</strong> <span id="player-xp"></span></div>
        <div><strong>Gold:</strong> <span id="player-gold"></span></div>
      </div>
      
      <div class="attributes">
        <h3>Attributes</h3>
        <div id="attributes-display"></div>
      </div>
      
      <div class="status-effects">
        <h3>Status Effects</h3>
        <div id="status-effects-display"></div>
      </div>
      
      <div class="session-info">
        <small id="session-cost">Session Cost: $0.00</small>
        <small id="model-info">Models: Loading...</small>
      </div>
    </aside>

    <!-- Main Panel: Narrative -->
    <main class="main-panel">
      <h1 id="game-title">Adventure</h1>
      
      <div id="narrative-display" class="narrative">
        <!-- Story text appears here -->
      </div>
      
      <div id="choices-panel" class="choices">
        <!-- Choice buttons appear here -->
      </div>
      
      <div class="custom-action">
        <input type="text" id="custom-action-input" placeholder="Or type your own action...">
        <button onclick="submitCustomAction()">Submit</button>
      </div>
    </main>

    <!-- Right Sidebar: Inventory & Companions -->
    <aside class="right-sidebar">
      <div class="collapsible-section">
        <h3 onclick="toggleSection('inventory')">üì¶ Inventory</h3>
        <div id="inventory" class="section-content">
          <h4>Weapons</h4>
          <ul id="weapons-list"></ul>
          <h4>Items</h4>
          <ul id="items-list"></ul>
          <h4>Spells</h4>
          <ul id="spells-list"></ul>
        </div>
      </div>
      
      <div class="collapsible-section">
        <h3 onclick="toggleSection('companions')">üë• Companions</h3>
        <div id="companions" class="section-content"></div>
      </div>
      
      <div class="collapsible-section">
        <h3 onclick="toggleSection('environment')">üó∫Ô∏è Environment</h3>
        <div id="environment" class="section-content">
          <strong>Current:</strong> <span id="current-location"></span>
          <div id="environment-details"></div>
        </div>
      </div>
      
      <div class="collapsible-section">
        <h3 onclick="toggleSection('history')">üìú Story Recap</h3>
        <div id="history" class="section-content">
          <ul id="recap-list"></ul>
        </div>
      </div>
    </aside>
  </div>

  <script src="game.js"></script>
</body>
</html>
```

## Implementation Files Structure

```
/dnd-game
  /public
    index.html
    style.css
  /src
    game.js           # Main game logic
    openrouter.js     # OpenRouter API functions
    stateManager.js   # Game state management
    uiController.js   # UI updates
    prompts.js        # System prompts for LLMs
  /data
    gameState.json    # Persisted game state
    config.json       # User's LLM selections
  server.js           # Backend (Node.js)
  package.json
```

## Backend Setup (Node.js)

```javascript
// server.js
const express = require('express');
const app = express();
app.use(express.json());
app.use(express.static('public'));

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;

// Proxy endpoint for OpenRouter (keeps API key server-side)
app.post('/api/llm', async (req, res) => {
  const { modelId, messages, systemPrompt, maxTokens } = req.body;
  
  try {
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
        'HTTP-Referer': req.headers.referer || 'http://localhost:3000',
        'X-Title': 'D&D Adventure Game',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: modelId,
        messages: [
          { role: 'system', content: systemPrompt },
          ...messages
        ],
        max_tokens: maxTokens,
        temperature: 0.7
      })
    });
    
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get available models
app.get('/api/models', async (req, res) => {
  try {
    const response = await fetch('https://openrouter.ai/api/v1/models', {
      headers: {
        'Authorization': `Bearer ${OPENROUTER_API_KEY}`
      }
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Save/load game state
const fs = require('fs').promises;

app.post('/api/save', async (req, res) => {
  await fs.writeFile('./data/gameState.json', JSON.stringify(req.body, null, 2));
  res.json({ success: true });
});

app.get('/api/load', async (req, res) => {
  try {
    const data = await fs.readFile('./data/gameState.json', 'utf8');
    res.json(JSON.parse(data));
  } catch (error) {
    res.json(null); // No save file
  }
});

app.listen(3000, () => console.log('Server running on port 3000'));
```

## Environment Setup

```bash
# .env file
OPENROUTER_API_KEY=your_key_here
```

```json
// package.json
{
  "name": "dnd-adventure",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "dotenv": "^16.0.3"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
```

Ready to implement! Would you like me to create the complete implementation code for any specific file?